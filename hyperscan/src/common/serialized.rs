use core::ops::Deref;
use core::ptr;
use core::slice;
use std::ffi::CStr;

use failure::Error;
use foreign_types::{ForeignType, ForeignTypeRef};

use crate::common::{Database, DatabaseRef};
use crate::errors::AsResult;

#[derive(Debug)]
pub struct SerializedDatabase(*const i8, usize);

impl Drop for SerializedDatabase {
    fn drop(&mut self) {
        unsafe { libc::free(self.0 as *mut _) }
    }
}

impl Deref for SerializedDatabase {
    type Target = [u8];

    fn deref(&self) -> &Self::Target {
        unsafe { slice::from_raw_parts(self.0 as *const _, self.1) }
    }
}

impl SerializedDatabase {
    pub fn size(&self) -> Result<usize, Error> {
        let mut size = 0;

        unsafe {
            ffi::hs_serialized_database_size(self.0, self.1, &mut size)
                .ok()
                .map(|_| size)
        }
    }

    pub fn info(&self) -> Result<String, Error> {
        let mut p = ptr::null_mut();

        unsafe {
            ffi::hs_serialized_database_info(self.0, self.1, &mut p)
                .ok()
                .and_then(|_| {
                    let info = CStr::from_ptr(p).to_str()?.to_owned();

                    if !p.is_null() {
                        libc::free(p as *mut _)
                    }

                    Ok(info)
                })
        }
    }
}

impl<T> Database<T> {
    /// Reconstruct a pattern database from a stream of bytes previously generated by `Database::serialize()`.
    pub fn deserialize(bytes: &[u8]) -> Result<Database<T>, Error> {
        let mut db = ptr::null_mut();

        unsafe {
            ffi::hs_deserialize_database(bytes.as_ptr() as *const i8, bytes.len(), &mut db)
                .ok()
                .map(|_| Database::from_ptr(db))
        }
    }
}

impl<T> DatabaseRef<T> {
    /// Serialize a pattern database to a stream of bytes.
    pub fn serialize(&self) -> Result<SerializedDatabase, Error> {
        let mut ptr = ptr::null_mut();
        let mut size: usize = 0;

        unsafe {
            ffi::hs_serialize_database(self.as_ptr(), &mut ptr, &mut size)
                .ok()
                .map(|_| SerializedDatabase(ptr as *mut _, size))
        }
    }

    /// Reconstruct a pattern database from a stream of bytes
    /// previously generated by `Database::serialize()` at a given memory location.
    pub fn deserialize_at(&mut self, bytes: &[u8]) -> Result<(), Error> {
        unsafe { ffi::hs_deserialize_database_at(bytes.as_ptr() as *const i8, bytes.len(), self.as_ptr()).ok() }
    }
}

#[cfg(test)]
pub mod tests {
    use crate::common::database::tests::*;
    use crate::common::*;
    use crate::compile::Flags;

    #[test]
    fn test_database_serialize() {
        let _ = pretty_env_logger::try_init();

        let db = StreamingDatabase::compile("test", Flags::empty(), None).unwrap();

        let data = db.serialize().unwrap();

        validate_serialized_database(&data);

        assert!(!data.info().unwrap().is_empty());
    }

    #[test]
    fn test_database_deserialize() {
        let _ = pretty_env_logger::try_init();

        let db = VectoredDatabase::compile("test", Flags::empty(), None).unwrap();

        let data = db.serialize().unwrap();

        let db = VectoredDatabase::deserialize(&data).unwrap();

        validate_database(&db);
    }

    #[test]
    fn test_database_deserialize_at() {
        let _ = pretty_env_logger::try_init();

        let mut db = BlockDatabase::compile("test", Flags::empty(), None).unwrap();

        let data = db.serialize().unwrap();

        db.deserialize_at(&data).unwrap();

        validate_database(&db);
    }
}
