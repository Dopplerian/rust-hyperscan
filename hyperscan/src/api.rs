use core::mem;

use failure::Error;
use foreign_types::{foreign_type, ForeignType};

use crate::constants::*;
use crate::database::Database;
use crate::errors::AsResult;

/// Compile mode
pub trait Mode {
    const ID: u32;
    const NAME: &'static str;
}

/// Block scan (non-streaming) database.
#[derive(Debug)]
pub enum Block {}

/// Streaming database.
#[derive(Debug)]
pub enum Streaming {}

/// Vectored scanning database.
#[derive(Debug)]
pub enum Vectored {}

impl Mode for Block {
    const ID: u32 = HS_MODE_BLOCK;
    const NAME: &'static str = "Block";
}

impl Mode for Streaming {
    const ID: u32 = HS_MODE_STREAM;
    const NAME: &'static str = "Streaming";
}

impl Mode for Vectored {
    const ID: u32 = HS_MODE_VECTORED;
    const NAME: &'static str = "Vectored";
}

// /// A pattern database can be serialized to a stream of bytes.
// pub trait SerializableDatabase<T: Database, S: SerializedDatabase>: Database {
//     /// Serialize a pattern database to a stream of bytes.
//     fn serialize(&self) -> Result<S, Error>;

//     /// Reconstruct a pattern database from a stream of bytes
//     /// previously generated by RawDatabase::serialize().
//     fn deserialize(bytes: &[u8]) -> Result<T, Error>;

//     /// Reconstruct a pattern database from a stream of bytes
//     /// previously generated by RawDatabase::serialize() at a given memory location.
//     fn deserialize_at(&self, bytes: &[u8]) -> Result<&T, Error>;
// }

// /// A pattern database was serialized to a stream of bytes.
// pub trait SerializedDatabase {
//     fn len(&self) -> usize;

//     fn as_slice(&self) -> &[u8];

//     fn deserialize<T: SerializableDatabase<D, S>, D: Database, S: SerializedDatabase>(&self) -> Result<D, Error> {
//         T::deserialize(self.as_slice())
//     }

//     fn database_size(&self) -> Result<usize, Error> {
//         let mut size: usize = 0;

//         unsafe {
//             check_hs_error!(hs_serialized_database_size(
//                 self.as_slice().as_ptr() as *const i8,
//                 self.len(),
//                 &mut size
//             ));
//         }

//         Ok(size)
//     }

//     fn database_info(&self) -> Result<String, Error> {
//         let mut p = ptr::null_mut();

//         unsafe {
//             check_hs_error!(hs_serialized_database_info(
//                 self.as_slice().as_ptr() as *const i8,
//                 self.len(),
//                 &mut p
//             ));

//             let result = match CStr::from_ptr(p).to_str() {
//                 Ok(info) => Ok(info.to_string()),
//                 Err(_) => Err(Invalid.into()),
//             };

//             libc::free(p as *mut libc::c_void);

//             result
//         }
//     }
// }

foreign_type! {
    /// A type containing information on the target platform
    /// which may optionally be provided to the compile calls
    pub type PlatformInfo {
        type CType = ffi::hs_platform_info_t;

        fn drop = free_platform_info;
    }
}

unsafe fn free_platform_info(p: *mut ffi::hs_platform_info_t) {
    let _ = Box::from_raw(p);
}

impl PlatformInfo {
    pub fn is_valid() -> Result<(), Error> {
        unsafe { ffi::hs_valid_platform().ok().map(|_| ()) }
    }

    pub fn host() -> Result<PlatformInfo, Error> {
        unsafe {
            let mut platform = mem::zeroed();

            ffi::hs_populate_platform(&mut platform)
                .ok()
                .map(|_| PlatformInfo::from_ptr(Box::into_raw(Box::new(platform))))
        }
    }

    pub fn new(tune: u32, cpu_features: u64) -> PlatformInfo {
        unsafe {
            PlatformInfo::from_ptr(Box::into_raw(Box::new(ffi::hs_platform_info_t {
                tune,
                cpu_features,
                reserved1: 0,
                reserved2: 0,
            })))
        }
    }
}

/// The regular expression pattern database builder.
pub trait Builder<T> {
    /// This is the function call with which an expression is compiled into
    /// a Hyperscan database which can be passed to the runtime functions
    fn build(&self) -> Result<Database<T>, Error> {
        self.build_for_platform(None)
    }

    fn build_for_platform(&self, platform: Option<&PlatformInfoRef>) -> Result<Database<T>, Error>;
}

/// A type containing information related to an expression
#[derive(Debug, Copy, Clone)]
pub struct ExpressionInfo {
    /// The minimum length in bytes of a match for the pattern.
    pub min_width: usize,

    /// The maximum length in bytes of a match for the pattern.
    pub max_width: usize,

    /// Whether this expression can produce matches that are not returned in order,
    /// such as those produced by assertions.
    pub unordered_matches: bool,

    /// Whether this expression can produce matches at end of data (EOD).
    pub matches_at_eod: bool,

    /// Whether this expression can *only* produce matches at end of data (EOD).
    pub matches_only_at_eod: bool,
}

/// Providing expression information.
pub trait Expression {
    ///
    /// Utility function providing information about a regular expression.
    ///
    /// The information provided in ExpressionInfo
    /// includes the minimum and maximum width of a pattern match.
    ///
    fn info(&self) -> Result<ExpressionInfo, Error>;
}

/// Flags modifying the behaviour of scan function
pub type ScanFlags = u32;

/// Definition of the match event callback function type.
///
/// This callback function will be invoked whenever a match is located in the
/// target data during the execution of a scan. The details of the match are
/// passed in as parameters to the callback function, and the callback function
/// should return a value indicating whether or not matching should continue on
/// the target data. If no callbacks are desired from a scan call, NULL may be
/// provided in order to suppress match production.
///
/// This callback function should not attempt to call Hyperscan API functions on
/// the same stream nor should it attempt to reuse the scratch space allocated
/// for the API calls that caused it to be triggered. Making another call to the
/// Hyperscan library with completely independent parameters should work (for
/// example, scanning a different database in a new stream and with new scratch
/// space), but reusing data structures like stream state and/or scratch space
/// will produce undefined behavior.
///
/// Fn(id: u32, from: u64, to: u64, flags: u32) -> bool
///
pub type MatchEventCallback<D> = Option<fn(id: u32, from: u64, to: u64, flags: u32, data: &D) -> u32>;
pub type MatchEventCallbackMut<D> = Option<fn(id: u32, from: u64, to: u64, flags: u32, data: &mut D) -> u32>;
